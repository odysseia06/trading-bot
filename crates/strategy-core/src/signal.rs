//! Signal types for expressing trading intent.

use execution_core::{OrderSide, OrderType, TimeInForce};
use rust_decimal::Decimal;

/// A trading signal generated by a strategy.
#[derive(Debug, Clone)]
pub struct Signal {
    /// ID of the strategy that generated this signal.
    pub strategy_id: String,
    /// The action to take.
    pub kind: SignalKind,
    /// Optional reason/description for the signal.
    pub reason: Option<String>,
    /// Timestamp when the signal was generated (ms since epoch).
    pub generated_at_ms: i64,
}

impl Signal {
    /// Create a new signal.
    pub fn new(strategy_id: impl Into<String>, kind: SignalKind) -> Self {
        Self {
            strategy_id: strategy_id.into(),
            kind,
            reason: None,
            generated_at_ms: 0, // Will be set by runner
        }
    }

    /// Create a new signal with a reason.
    pub fn with_reason(
        strategy_id: impl Into<String>,
        kind: SignalKind,
        reason: impl Into<String>,
    ) -> Self {
        Self {
            strategy_id: strategy_id.into(),
            kind,
            reason: Some(reason.into()),
            generated_at_ms: 0,
        }
    }

    /// Create an order signal.
    pub fn order(strategy_id: impl Into<String>, intent: OrderIntent) -> Self {
        Self::new(strategy_id, SignalKind::Order(intent))
    }

    /// Create a cancel signal.
    pub fn cancel(strategy_id: impl Into<String>, intent: CancelIntent) -> Self {
        Self::new(strategy_id, SignalKind::Cancel(intent))
    }

    /// Create a modify signal.
    pub fn modify(strategy_id: impl Into<String>, intent: ModifyIntent) -> Self {
        Self::new(strategy_id, SignalKind::Modify(intent))
    }
}

/// The type of signal action.
#[derive(Debug, Clone)]
pub enum SignalKind {
    /// Place a new order.
    Order(OrderIntent),
    /// Cancel an existing order.
    Cancel(CancelIntent),
    /// Modify an existing order (cancel + replace).
    Modify(ModifyIntent),
}

/// Intent to place a new order.
#[derive(Debug, Clone)]
pub struct OrderIntent {
    /// Trading pair symbol (e.g., "BTCUSDT").
    pub symbol: String,
    /// Buy or sell.
    pub side: OrderSide,
    /// Order type (market, limit, etc.).
    pub order_type: OrderType,
    /// Quantity to trade.
    pub quantity: Decimal,
    /// Limit price (required for limit orders).
    pub price: Option<Decimal>,
    /// Time in force (optional, defaults to GTC for limit orders).
    pub time_in_force: Option<TimeInForce>,
}

impl OrderIntent {
    /// Create a market buy order.
    pub fn market_buy(symbol: impl Into<String>, quantity: Decimal) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Buy,
            order_type: OrderType::Market,
            quantity,
            price: None,
            time_in_force: None,
        }
    }

    /// Create a market sell order.
    pub fn market_sell(symbol: impl Into<String>, quantity: Decimal) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Sell,
            order_type: OrderType::Market,
            quantity,
            price: None,
            time_in_force: None,
        }
    }

    /// Create a limit buy order.
    pub fn limit_buy(symbol: impl Into<String>, quantity: Decimal, price: Decimal) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Buy,
            order_type: OrderType::Limit,
            quantity,
            price: Some(price),
            time_in_force: Some(TimeInForce::GTC),
        }
    }

    /// Create a limit sell order.
    pub fn limit_sell(symbol: impl Into<String>, quantity: Decimal, price: Decimal) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Sell,
            order_type: OrderType::Limit,
            quantity,
            price: Some(price),
            time_in_force: Some(TimeInForce::GTC),
        }
    }

    /// Create a limit buy order with custom time-in-force.
    pub fn limit_buy_with_tif(
        symbol: impl Into<String>,
        quantity: Decimal,
        price: Decimal,
        tif: TimeInForce,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Buy,
            order_type: OrderType::Limit,
            quantity,
            price: Some(price),
            time_in_force: Some(tif),
        }
    }

    /// Create a limit sell order with custom time-in-force.
    pub fn limit_sell_with_tif(
        symbol: impl Into<String>,
        quantity: Decimal,
        price: Decimal,
        tif: TimeInForce,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            side: OrderSide::Sell,
            order_type: OrderType::Limit,
            quantity,
            price: Some(price),
            time_in_force: Some(tif),
        }
    }
}

/// Intent to cancel an existing order.
#[derive(Debug, Clone)]
pub struct CancelIntent {
    /// Trading pair symbol.
    pub symbol: String,
    /// Client order ID to cancel.
    pub client_order_id: String,
}

impl CancelIntent {
    /// Create a new cancel intent.
    pub fn new(symbol: impl Into<String>, client_order_id: impl Into<String>) -> Self {
        Self {
            symbol: symbol.into(),
            client_order_id: client_order_id.into(),
        }
    }
}

/// Intent to modify an existing order (implemented as cancel + new order).
#[derive(Debug, Clone)]
pub struct ModifyIntent {
    /// Trading pair symbol.
    pub symbol: String,
    /// Client order ID of the order to modify.
    pub original_client_order_id: String,
    /// New quantity (None to keep original).
    pub new_quantity: Option<Decimal>,
    /// New price (None to keep original).
    pub new_price: Option<Decimal>,
}

impl ModifyIntent {
    /// Create a modify intent to change price only.
    pub fn new_price(
        symbol: impl Into<String>,
        original_client_order_id: impl Into<String>,
        price: Decimal,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            original_client_order_id: original_client_order_id.into(),
            new_quantity: None,
            new_price: Some(price),
        }
    }

    /// Create a modify intent to change quantity only.
    pub fn new_quantity(
        symbol: impl Into<String>,
        original_client_order_id: impl Into<String>,
        quantity: Decimal,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            original_client_order_id: original_client_order_id.into(),
            new_quantity: Some(quantity),
            new_price: None,
        }
    }

    /// Create a modify intent to change both price and quantity.
    pub fn new_price_and_quantity(
        symbol: impl Into<String>,
        original_client_order_id: impl Into<String>,
        price: Decimal,
        quantity: Decimal,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            original_client_order_id: original_client_order_id.into(),
            new_quantity: Some(quantity),
            new_price: Some(price),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;

    #[test]
    fn test_market_buy() {
        let intent = OrderIntent::market_buy("BTCUSDT", dec!(0.01));
        assert_eq!(intent.symbol, "BTCUSDT");
        assert_eq!(intent.side, OrderSide::Buy);
        assert_eq!(intent.order_type, OrderType::Market);
        assert_eq!(intent.quantity, dec!(0.01));
        assert!(intent.price.is_none());
    }

    #[test]
    fn test_limit_sell() {
        let intent = OrderIntent::limit_sell("BTCUSDT", dec!(0.01), dec!(50000));
        assert_eq!(intent.side, OrderSide::Sell);
        assert_eq!(intent.order_type, OrderType::Limit);
        assert_eq!(intent.price, Some(dec!(50000)));
        assert_eq!(intent.time_in_force, Some(TimeInForce::GTC));
    }

    #[test]
    fn test_signal_creation() {
        let signal = Signal::order("my_strategy", OrderIntent::market_buy("BTCUSDT", dec!(1)));
        assert_eq!(signal.strategy_id, "my_strategy");
        assert!(signal.reason.is_none());
        assert!(matches!(signal.kind, SignalKind::Order(_)));
    }

    #[test]
    fn test_signal_with_reason() {
        let signal = Signal::with_reason(
            "my_strategy",
            SignalKind::Order(OrderIntent::market_buy("BTCUSDT", dec!(1))),
            "Price crossed threshold",
        );
        assert_eq!(signal.reason, Some("Price crossed threshold".into()));
    }

    #[test]
    fn test_cancel_intent() {
        let intent = CancelIntent::new("BTCUSDT", "order_123");
        assert_eq!(intent.symbol, "BTCUSDT");
        assert_eq!(intent.client_order_id, "order_123");
    }

    #[test]
    fn test_modify_intent() {
        let intent = ModifyIntent::new_price("BTCUSDT", "order_123", dec!(51000));
        assert!(intent.new_price.is_some());
        assert!(intent.new_quantity.is_none());
    }
}
